<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry&#39;s blog</title>
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-30T08:25:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Henry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 内存管理笔记</title>
    <link href="http://yoursite.com/2016/11/30/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/11/30/iOS-内存管理笔记/</id>
    <published>2016-11-30T08:21:51.000Z</published>
    <updated>2016-11-30T08:25:38.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;内存管理的思考方式&quot;&gt;&lt;a href=&quot;#内存管理的思考方式&quot; class=&quot;headerlink&quot; title=&quot;内存管理的思考方式&quot;&gt;&lt;/a&gt;内存管理的思考方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自己生成的对象，自己持有&lt;/li&gt;
&lt;li&gt;非自己生成的对象，自己也能持有&lt;/li&gt;
&lt;li&gt;不再需要自己持有的对象时释放&lt;/li&gt;
&lt;li&gt;非自己持有的对象无法释放&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;自己生成的对象，自己持有&quot;&gt;&lt;a href=&quot;#自己生成的对象，自己持有&quot; class=&quot;headerlink&quot; title=&quot;自己生成的对象，自己持有&quot;&gt;&lt;/a&gt;自己生成的对象，自己持有&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;alloc&lt;/code&gt;,&lt;code&gt;new&lt;/code&gt;,&lt;code&gt;copy&lt;/code&gt;和&lt;code&gt;mutableCopy&lt;/code&gt;开头的方法生成的对象，自己持有。引用计数从0变成1。&lt;/p&gt;
&lt;h3 id=&quot;非自己生成的对象，自己也能持有&quot;&gt;&lt;a href=&quot;#非自己生成的对象，自己也能持有&quot; class=&quot;headerlink&quot; title=&quot;非自己生成的对象，自己也能持有&quot;&gt;&lt;/a&gt;非自己生成的对象，自己也能持有&lt;/h3&gt;&lt;p&gt;通过使用&lt;code&gt;alloc&lt;/code&gt;,&lt;code&gt;new&lt;/code&gt;,&lt;code&gt;copy&lt;/code&gt;和&lt;code&gt;mutableCopy&lt;/code&gt;以外的方法生成的对象，因为非自己生成并持有，所以自己不是该对象的持有者。可以使用&lt;code&gt;retain&lt;/code&gt;方法来持有对象，使得引用计数+1。&lt;/p&gt;
&lt;h3 id=&quot;不再需要自己持有的对象时释放该对象&quot;&gt;&lt;a href=&quot;#不再需要自己持有的对象时释放该对象&quot; class=&quot;headerlink&quot; title=&quot;不再需要自己持有的对象时释放该对象&quot;&gt;&lt;/a&gt;不再需要自己持有的对象时释放该对象&lt;/h3&gt;&lt;p&gt;对于不再需要的对象，要通过&lt;code&gt;release&lt;/code&gt;方法使得对象的引用计数-1，当对象的引用计数变为0时，对象被废弃。&lt;/p&gt;
&lt;h3 id=&quot;非自己持有的对象无法释放&quot;&gt;&lt;a href=&quot;#非自己持有的对象无法释放&quot; class=&quot;headerlink&quot; title=&quot;非自己持有的对象无法释放&quot;&gt;&lt;/a&gt;非自己持有的对象无法释放&lt;/h3&gt;&lt;p&gt;通过&lt;code&gt;alloc&lt;/code&gt;,&lt;code&gt;new&lt;/code&gt;,&lt;code&gt;copy&lt;/code&gt;和&lt;code&gt;mutableCopy&lt;/code&gt;方法生成并持有的对象 ，或者通过&lt;code&gt;retain&lt;/code&gt;方法来持有的其它生成的对象，在不需要该对象时可以通过&lt;code&gt;release&lt;/code&gt;方法来释放该对象，如果长时间的不释放这些无用的对象，会造成系统的内存使用紧张和内存泄露。但是如果在应用中释放了不是自己持有的对象会造成应用崩溃。&lt;br&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己生成并持有的对象，在释放后不能再次释放该对象&lt;/li&gt;
&lt;li&gt;不能释放其它生成，但自己不持有的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;autorelease和release&quot;&gt;&lt;a href=&quot;#autorelease和release&quot; class=&quot;headerlink&quot; title=&quot;autorelease和release&quot;&gt;&lt;/a&gt;autorelease和release&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用autorelease可以使取得的对象存在，但不持有该对象&lt;/li&gt;
&lt;li&gt;autorelease能够使对象在超出指定的生存范围时能够自动并正确地释放&lt;/li&gt;
&lt;li&gt;autorelease可以看作是延迟调用了release方法来释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ARC自动引用计数&quot;&gt;&lt;a href=&quot;#ARC自动引用计数&quot; class=&quot;headerlink&quot; title=&quot;ARC自动引用计数&quot;&gt;&lt;/a&gt;ARC自动引用计数&lt;/h2&gt;&lt;h3 id=&quot;什么是自动引用计数&quot;&gt;&lt;a href=&quot;#什么是自动引用计数&quot; class=&quot;headerlink&quot; title=&quot;什么是自动引用计数&quot;&gt;&lt;/a&gt;什么是自动引用计数&lt;/h3&gt;&lt;p&gt;OC中采用ARC机制，Apple使用新的LLVM编译器来进行内存管理，在代码编译期间会在相应的代码位置加入合适的&lt;code&gt;retain&lt;/code&gt;和&lt;code&gt;release&lt;/code&gt;方法来管理对象的引用计数。&lt;/p&gt;
&lt;h3 id=&quot;对象的所有权修饰符&quot;&gt;&lt;a href=&quot;#对象的所有权修饰符&quot; class=&quot;headerlink&quot; title=&quot;对象的所有权修饰符&quot;&gt;&lt;/a&gt;对象的所有权修饰符&lt;/h3&gt;&lt;p&gt;ARC有效时，id类型和对象类型必须附加所有权修饰符。&lt;br&gt;所有权修饰符一共有4种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;__strong修饰符&lt;/li&gt;
&lt;li&gt;__weak修饰符&lt;/li&gt;
&lt;li&gt;__unsafe _unretained修饰符&lt;/li&gt;
&lt;li&gt;__autoreleasing修饰符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;strong修饰符&quot;&gt;&lt;a href=&quot;#strong修饰符&quot; class=&quot;headerlink&quot; title=&quot;__strong修饰符&quot;&gt;&lt;/a&gt;__strong修饰符&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;strong修饰符是id类型和对象类型的默认的所有权修饰符。 &lt;/strong&gt;strong修饰符表示对对象的&lt;strong&gt;强引用&lt;/strong&gt;，使用__strong修饰符的变量会保留对象的值。当变量在超出其变量作用域时，即变量被废弃时，会释放其所持有的对象。&lt;/p&gt;
&lt;h3 id=&quot;weak修饰符&quot;&gt;&lt;a href=&quot;#weak修饰符&quot; class=&quot;headerlink&quot; title=&quot;__weak修饰符&quot;&gt;&lt;/a&gt;__weak修饰符&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;weak修饰符表示对对象的&lt;strong&gt;弱引用&lt;/strong&gt;， 使用 &lt;/strong&gt;weak修饰符的变量不会保留对象的值，也不会持有对象实例。当 &lt;strong&gt;weak修饰的变量所指向的对象废弃时，变量会自动赋值为nil。&lt;br&gt;使用 &lt;/strong&gt;weak修饰符可以避免循环引用的发生。&lt;/p&gt;
&lt;h3 id=&quot;unsafe-unretained修饰符&quot;&gt;&lt;a href=&quot;#unsafe-unretained修饰符&quot; class=&quot;headerlink&quot; title=&quot;__unsafe _unretained修饰符&quot;&gt;&lt;/a&gt;__unsafe _unretained修饰符&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;unsafe _unretained修饰符是不安全的修饰符，和 &lt;/strong&gt;weak修饰符一样，不保留变量的值，也不会持有对象。当 &lt;strong&gt;unsafe _unretained修饰的变量所指向的对象废弃时，变量会被废弃，成为一个悬指针，不会像 &lt;/strong&gt;weak自动赋值为nil。需要注意的一点，附加了 __unsafe _unretained修饰符的变量不属于编译器内存管理的对象。&lt;/p&gt;
&lt;h3 id=&quot;autoreleasing修饰符&quot;&gt;&lt;a href=&quot;#autoreleasing修饰符&quot; class=&quot;headerlink&quot; title=&quot;__autoreleasing修饰符&quot;&gt;&lt;/a&gt;__autoreleasing修饰符&lt;/h3&gt;&lt;p&gt;ARC有效时，使用&lt;code&gt;@autoreleasepool&lt;/code&gt;快来替代&lt;code&gt;NSAutoreleasePool&lt;/code&gt;类对象生成、持有以及废弃这一范围。&lt;br&gt;通过对变量附加了__autoreleaseing修饰符来替代调用&lt;code&gt;autorelease&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id=&quot;ARC规则&quot;&gt;&lt;a href=&quot;#ARC规则&quot; class=&quot;headerlink&quot; title=&quot;ARC规则&quot;&gt;&lt;/a&gt;ARC规则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不能显示的使用&lt;code&gt;retain&lt;/code&gt;/&lt;code&gt;release&lt;/code&gt;/&lt;code&gt;retainCount&lt;/code&gt;/&lt;code&gt;autorelease&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;不能使用&lt;code&gt;NSAllocateObject&lt;/code&gt;/&lt;code&gt;NSDeallocateObject&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;必须遵守内存管理的方法命名规则&lt;/li&gt;
&lt;li&gt;不要显示的调用&lt;code&gt;dealloc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;@autoreleasepool&lt;/code&gt;块替代&lt;code&gt;NSAutoreleasePool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不能使用区域&lt;code&gt;NSZone&lt;/code&gt;（为了防止内存碎片化引入的结构）&lt;/li&gt;
&lt;li&gt;对象型变量不能作为C语言结构体的成员&lt;/li&gt;
&lt;li&gt;显示转换&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;void *&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;对象型变量不能作为C语言结构体的成员&quot;&gt;&lt;a href=&quot;#对象型变量不能作为C语言结构体的成员&quot; class=&quot;headerlink&quot; title=&quot;对象型变量不能作为C语言结构体的成员&quot;&gt;&lt;/a&gt;对象型变量不能作为C语言结构体的成员&lt;/h3&gt;&lt;p&gt;因为ARC把内存管理的工作交给了编译器，所以编译器必须能够知道并管理对象的生存周期。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理的思考方式&quot;&gt;&lt;a href=&quot;#内存管理的思考方式&quot; class=&quot;headerlink&quot; title=&quot;内存管理的思考方式&quot;&gt;&lt;/a&gt;内存管理的思考方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自己生成的对象，自己持有&lt;/li&gt;
&lt;li&gt;非自己生成的对象，自己也能持有&lt;/li&gt;
&lt;li&gt;不再需要自己持有的对象时释放&lt;/li&gt;
&lt;li&gt;非自己持有的对象无法释放&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS多国化学习笔记</title>
    <link href="http://yoursite.com/2016/11/22/iOS%E5%A4%9A%E5%9B%BD%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/11/22/iOS多国化学习笔记/</id>
    <published>2016-11-22T10:00:43.000Z</published>
    <updated>2016-11-23T10:01:22.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;xib和storyboard文件&quot;&gt;&lt;a href=&quot;#xib和storyboard文件&quot; class=&quot;headerlink&quot; title=&quot;xib和storyboard文件&quot;&gt;&lt;/a&gt;xib和storyboard文件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Project -&amp;gt; Localizations中选择需要本地化的语言&lt;/li&gt;
&lt;li&gt;xib文件选择Localization中的Base，并勾选需要本地化的语言&lt;/li&gt;
&lt;li&gt;storyboard文件中Localization中，勾选Base（默认已经勾选）和需要本地化的语言&lt;/li&gt;
&lt;li&gt;在相应的XXX.lproj目录中，找到XXX.strings文件，修改需要本地化的内容&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码中的文字&quot;&gt;&lt;a href=&quot;#代码中的文字&quot; class=&quot;headerlink&quot; title=&quot;代码中的文字&quot;&gt;&lt;/a&gt;代码中的文字&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;找到需要本地化的内容，替换成&lt;code&gt;NSLocalizedString(key, comment: comment)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用命令&lt;code&gt;genstrings *.swift -o en.lproj&lt;/code&gt;行生成Localizabel.strings文件&lt;/li&gt;
&lt;li&gt;添加生成的strings文件到工具目录，并且勾选和需要本地化的语言&lt;/li&gt;
&lt;li&gt;修改需要本地化的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;InfoPlist-strings&quot;&gt;&lt;a href=&quot;#InfoPlist-strings&quot; class=&quot;headerlink&quot; title=&quot;InfoPlist.strings&quot;&gt;&lt;/a&gt;InfoPlist.strings&lt;/h2&gt;&lt;p&gt;可以修改plist中显示的内容，例如App的名字&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;xib和storyboard文件&quot;&gt;&lt;a href=&quot;#xib和storyboard文件&quot; class=&quot;headerlink&quot; title=&quot;xib和storyboard文件&quot;&gt;&lt;/a&gt;xib和storyboard文件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Project -&amp;gt; Localizations中选择需要本地化的语言&lt;/li&gt;
&lt;li&gt;xib文件选择Localization中的Base，并勾选需要本地化的语言&lt;/li&gt;
&lt;li&gt;storyboard文件中Localization中，勾选Base（默认已经勾选）和需要本地化的语言&lt;/li&gt;
&lt;li&gt;在相应的XXX.lproj目录中，找到XXX.strings文件，修改需要本地化的内容
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS隐藏键盘</title>
    <link href="http://yoursite.com/2016/09/20/iOS%E9%9A%90%E8%97%8F%E9%94%AE%E7%9B%98/"/>
    <id>http://yoursite.com/2016/09/20/iOS隐藏键盘/</id>
    <published>2016-09-20T08:06:28.000Z</published>
    <updated>2016-11-23T09:59:31.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在开发App的过程中，经常要求用户进行输入操作，比如登陆过程中要求输入用户名和密码。但是有可能弹出的keyboard把登陆button挡住了，从而无法点击button。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;p&gt;可以通过实现隐藏键盘来解决这类问题。隐藏键盘的方法也有好几种，比如利用键盘的return键来实现隐藏，也可以通过点击view上其它的空白处来实现隐藏，或者通过响应自定义手势来隐藏，还可以通过给软键盘增加一个toolbar，在toolbar上面添加按钮来实现隐藏键盘，当然还有其它没有提及的方法。&lt;br&gt;常用的隐藏键盘的两个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[view endEditing:YES];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[textField resignFirstResponder];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;点击View空白处隐藏键盘&quot;&gt;&lt;a href=&quot;#点击View空白处隐藏键盘&quot; class=&quot;headerlink&quot; title=&quot;点击View空白处隐藏键盘&quot;&gt;&lt;/a&gt;点击View空白处隐藏键盘&lt;/h3&gt;&lt;h4 id=&quot;1-重写touchesBegan-withEvent-方法&quot;&gt;&lt;a href=&quot;#1-重写touchesBegan-withEvent-方法&quot; class=&quot;headerlink&quot; title=&quot;1.重写touchesBegan: withEvent:方法&quot;&gt;&lt;/a&gt;1.重写&lt;code&gt;touchesBegan: withEvent:&lt;/code&gt;方法&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    UITouch *touch = [[event allTouches] anyObject];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if ([textField isFirstResponder] &amp;amp;&amp;amp; [touch view] != textField) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [self.view endEditing:YES];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [super touchesBegan: touches withEvent: event];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-利用UIControl响应点击方法&quot;&gt;&lt;a href=&quot;#2-利用UIControl响应点击方法&quot; class=&quot;headerlink&quot; title=&quot;2.利用UIControl响应点击方法&quot;&gt;&lt;/a&gt;2.利用UIControl响应点击方法&lt;/h4&gt;&lt;p&gt;修改xib或storyb中相关view的Custom Class为UIControl（默认是UIView），在UIControl中实现点击隐藏键盘的功能&lt;br&gt;&lt;img src=&quot;https://s3.amazonaws.com/f.cl.ly/items/0A372Y2l2w0934062w40/uicontrol.png&quot; alt=&quot;UIControl&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//ViewController.h&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@interface ViewController: UIViewController&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (IBAction)hideKeyboarder:(id)sender;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@end&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//ViewController.m&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#import &amp;quot;ViewController.h&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@implemetation ViewController&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (IBAction)hideKeyboarder:(id)sender &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [self.view endEiting:YES];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@end&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3-添加点击的手势，实现隐藏键盘&quot;&gt;&lt;a href=&quot;#3-添加点击的手势，实现隐藏键盘&quot; class=&quot;headerlink&quot; title=&quot;3.添加点击的手势，实现隐藏键盘&quot;&gt;&lt;/a&gt;3.添加点击的手势，实现隐藏键盘&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hideKeyboard:)];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	[self.view addGestureRecognizer:tapGestureRecognizer];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (void)hideKeyboard:(UITapGestureRecognizer *)tap &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	[self.view endEditing:YES];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;点击return键实现隐藏键盘&quot;&gt;&lt;a href=&quot;#点击return键实现隐藏键盘&quot; class=&quot;headerlink&quot; title=&quot;点击return键实现隐藏键盘&quot;&gt;&lt;/a&gt;点击return键实现隐藏键盘&lt;/h3&gt;&lt;p&gt;通过给textField添加响应&lt;em&gt;Did End On Exit&lt;/em&gt;事件的方法来实现隐藏keyboard的功能。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (IBAction)returnKeyboard:(id)sender &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [sender resignFirstResponder];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用这种方法隐藏键盘会有个问题，如果有多个textField存在的话，需要为每一个textField添加响应&lt;em&gt;Did End On Exit&lt;/em&gt;事件的方法，有时候return键可以需要实现其它的功能。&lt;/p&gt;
&lt;h3 id=&quot;键盘添加一个toolbar，toolbar上添加button来实现隐藏功能&quot;&gt;&lt;a href=&quot;#键盘添加一个toolbar，toolbar上添加button来实现隐藏功能&quot; class=&quot;headerlink&quot; title=&quot;键盘添加一个toolbar，toolbar上添加button来实现隐藏功能&quot;&gt;&lt;/a&gt;键盘添加一个toolbar，toolbar上添加button来实现隐藏功能&lt;/h3&gt;&lt;p&gt;首先看一下效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.amazonaws.com/f.cl.ly/items/1x0g381a32130n1L3e0i/keyboardToolbar.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (void)addToolbarToKeyboard &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    UIToolbar *toolbar = [[UIToolbar alloc] initWithFrame:CGRect(0, 0, 320, 30)];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    UIBarButtonItem *spaceButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:self action:nil];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    UIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:self action:@selector(hideKeyboard:)];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [toolbar setItems:@[spaceButton, doneButton]];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    textField.inputAccessoryView = toolbar;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (void)hideKeyboard:(id)sender &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [textField resignFirstResponder];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;3-Demo&quot;&gt;&lt;a href=&quot;#3-Demo&quot; class=&quot;headerlink&quot; title=&quot;3.Demo&quot;&gt;&lt;/a&gt;3.Demo&lt;/h2&gt;&lt;p&gt;以上简单的实现了隐藏键盘的方法。&lt;a href=&quot;https://github.com/xiaobinhuang/HideKeyboard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码地址&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在开发App的过程中，经常要求用户进行输入操作，比如登陆过程中要求输入用户名和密码。但是有可能弹出的keyboard把登陆button挡住了，从而无法点击button。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS之初识RunLoop</title>
    <link href="http://yoursite.com/2016/08/26/iOS%E4%B9%8B%E5%88%9D%E8%AF%86RunLoop/"/>
    <id>http://yoursite.com/2016/08/26/iOS之初识RunLoop/</id>
    <published>2016-08-26T07:18:11.000Z</published>
    <updated>2016-11-23T09:58:45.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章是自己对于学习iOS底层的 RunLoop 的一个整理和记录，主要参考了 Apple 的官方文档和网上大神们的文章，然后加以自己的理解和验证完成的。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;什么是-RunLoop？&quot;&gt;&lt;a href=&quot;#什么是-RunLoop？&quot; class=&quot;headerlink&quot; title=&quot;什么是 RunLoop？&quot;&gt;&lt;/a&gt;什么是 RunLoop？&lt;/h2&gt;&lt;p&gt;先来看看Apple文档对RunLoop的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Run loops are part of the fundamental infrastructur associated with threads. A run loop is an event processing loop that you use to schedule work and coordinate the recipt of incoming events. The purpose of run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none. &lt;/p&gt;
&lt;p&gt;Run loop management is not entirely automatic. You must sitll design your thread’s code to start the run loop appropriate times and respond to incoming events. Both Cocoa and Core Foundation provide &lt;em&gt;run loop objects&lt;/em&gt; to help you configure and manage your thread’s run loop. Your application does not need to create these objects explicitly; each thread, including the application’s main thread, has an associated run loop object. Only secondry threads need to run loop explicitly, however. The app frameworks automatically set up and run the run loop on the main thread as part of the application startup process.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照文档的字面意思大致可以理解为：&lt;/p&gt;
&lt;p&gt;RunLoop 是和线程相关的基础架构的一部分，所以和线程的关系应该很紧密。我们可以把 RunLoop 拆L成 Run 和 Loop 两部分来理解，先来看 Loop 的意思：Loop 就是一个循环的过程，这个循环过程是用来处理事件的。再来看 Run 的意思：就是跑起来，不要停，驱使 Loop 在线程中一直跑着。合起来看 RunLoop 就是一个循环处理事件的过程。在这个过程中 RunLoop 要确保线程在有活要干的时候立马能起来干活，没活干的时候赶紧睡觉，不要浪费宝贵的资源。&lt;/p&gt;
&lt;p&gt;RunLoop的管理不是完全自动的，需要我们在设计线程代码的时候在适当的时候去启动它正确的响应输入事件。CocoaL和 Core Foundation 为我们提供了run loop objects来帮助我们配置和管理我们线程中的 RunLoop。每一个线程，包括主线程，都有一个与之相关联的 RunLoop。在程序中，作为应用启动的一部分，主线程会自动的设置和启动它的 RunLoop，而其它的辅助线程则需要我们显示的启动运行RunLoop。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;App的启动过程&quot;&gt;&lt;a href=&quot;#App的启动过程&quot; class=&quot;headerlink&quot; title=&quot;App的启动过程&quot;&gt;&lt;/a&gt;App的启动过程&lt;/h2&gt;&lt;p&gt;我们先来看一下App启动过程中的main函数：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;int main(int argc, char *argv[]) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @autoreleasepool &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为什么main函数执行结束后，程序没有退出呢？而是能够继续维持运行呢？&lt;br&gt;这背后的原因就是run loop在起作用。因为主线程中的run loop是作为程序启动的一部分而自动运行的，所以我们的程序不会退出，而是一直在等待事件到来，处理事件，再等待的循环中运行着，直到程序的退出。&lt;/p&gt;
&lt;p&gt;可以借用下面的图来加深理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocgehzzvy.bkt.clouddn.com/appLiftCycle.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过在程序中加断点我们可以清楚的发现主线程中run loop的启动过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocgehzzvy.bkt.clouddn.com/runLoop%E5%90%AF%E5%8A%A8.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Run-loop-Run-loop-object和线程的关系？&quot;&gt;&lt;a href=&quot;#Run-loop-Run-loop-object和线程的关系？&quot; class=&quot;headerlink&quot; title=&quot;Run loop/Run loop object和线程的关系？&quot;&gt;&lt;/a&gt;Run loop/Run loop object和线程的关系？&lt;/h2&gt;&lt;p&gt;简单的来说，线程就是在系统中用来执行任务的最小单位。通常一个线程一次只能执行一个任务，而且执行任务的控制流是顺序的，当任务执行完成后，线程也会随之结束退出。&lt;/p&gt;
&lt;p&gt;Run loop的作用就是能够保证线程在任务执行完成后，紧接着不会随着退出。而是继续运行着，等待响应新事件的到来。&lt;/p&gt;
&lt;p&gt;从Apple文档中可以看出，run loop 其实是一个对象，是寄生于线程中的，和线程具有一一对应的关系。在Mac OS/iOS系统中，线程中已经存在了与之对应的run loop object，我们再不需要为线程显示的创建一个run loop object。Apple也不允许我们自己为线程创建run loop object，在&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSRunLoop&lt;/a&gt;和&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/doc/uid/20001441&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CFRunLoop&lt;/a&gt;的文档中只有获取线程内run loop object的方法，而没有新建run loop object的方法。&lt;/p&gt;
&lt;p&gt;系统为我们提供了两个run loop对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSRunLoop:是对CFRunLoopRef的面向对象的封装，是&lt;strong&gt;线程不安全&lt;/strong&gt;的 &lt;/li&gt;
&lt;li&gt;CFRunLoopRef:是在CoreFoundation框架内，是纯C函数的API，是&lt;strong&gt;线程安全&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CFRunLoopRef为我们提供了两个方法来获取线程中的run loop对象，&lt;strong&gt;CFRunLoopGetMain()&lt;/strong&gt;    和&lt;strong&gt;CFRunLoopGetCurrent()&lt;/strong&gt;,我们可以查看CFRunLoop的&lt;a href=&quot;http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;开源代码&lt;/a&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/*全局量dict，用来记录线程对应的run loop 对象，&amp;lt;key: value&amp;gt;对应&amp;lt;线程pthread的指针: CFRunLoop对象&amp;gt;*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;static CFMutableDictionaryRef __CFRunLoops = NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;static CFSpinLock_t loopsLock = CFSpinLockInit;     /*访问全局量时用到的锁*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CFRunLoopRef _CFRunLoopGet0(pthread_t t) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    __CFSpinLock(&amp;amp;loopsLock);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /*1. 第一次启动时，系统中没有run loop对象，全局量dict不存在，需要初始化全局量 */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (!__CFRunLoops) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        __CFSpinUnlock(&amp;amp;loopsLock);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;amp;kCFTypeDictionaryValueCallBacks);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    // 首先是为主线程创建一个run loop对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;amp;__CFRunLoops)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	        CFRelease(dict);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    CFRelease(mainLoop);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        __CFSpinLock(&amp;amp;loopsLock);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* 2. 如果程序中已经存在一个记录run loop对象的全局量dict，试图获取线程对应的run loop对象 */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    __CFSpinUnlock(&amp;amp;loopsLock);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /*3. 线程对应的run loop对象获取失败，则为这个线程新建一个run loop对象 */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (!loop) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    CFRunLoopRef newLoop = __CFRunLoopCreate(t);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        __CFSpinLock(&amp;amp;loopsLock);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    if (!loop) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	        /* 更新全局量中的记录*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	        loop = newLoop;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        __CFSpinUnlock(&amp;amp;loopsLock);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    CFRelease(newLoop);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //注册回调RunLoop结束时的回调函数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (pthread_equal(t, pthread_self())) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return loop;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/*获取主线程run loop的方法*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CFRunLoopRef CFRunLoopGetMain(void) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    static CFRunLoopRef __main = NULL; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return __main;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/*获取当前线程run loop的方法*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CFRunLoopRef CFRunLoopGetCurrent(void) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (rl) return rl;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return _CFRunLoopGet0(pthread_self());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从代码中，我们可以发现线程和run loop对象是一一对应的，记录在一个全局的dictionary里。创建线程的时候，并不会自动生成相应的run loop对象，只有主动获取run loop对象的时候才会创建相应的run loop对象。主线程是个特例，它在创建的时候就自动生成了相应的run loop对象。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Run-Loop解析&quot;&gt;&lt;a href=&quot;#Run-Loop解析&quot; class=&quot;headerlink&quot; title=&quot;Run Loop解析&quot;&gt;&lt;/a&gt;Run Loop解析&lt;/h2&gt;&lt;p&gt;Run loop本身听起来和它的名字很像，它是一个循环，允许你的线程进入和用它来运行响应接收事件的处理程序。我们的代码要提供实现循环部分的控制语句，比如使用while或for来驱动RunLoop。在循环中，我们使用&lt;em&gt;run loop object&lt;/em&gt;来运行事件的处理程序，它响应接收事件并运行处理程序。&lt;/p&gt;
&lt;p&gt;我们可以先看一下，Apple给我们画的run loop的模型图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocgehzzvy.bkt.clouddn.com/runloopWorkflow.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;Run Loop从两个不同的事件源中接收消息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Input sources&lt;/code&gt;：异步传递的事件，通常来自其它线程或其它的应用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Timer sources&lt;/code&gt;：同步传递的事件，在特定时间发生的事件或者重复发生的事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了处理输入源，run loops也会生成关于run loop行为的通知(notifications)。注册的run loop观察者(run-loop Observers)可以收到这些通知，并在线程上面使用它们来做额外的处理。&lt;/p&gt;
&lt;p&gt;RunLoop中最关键的是要理解其中的&lt;strong&gt;RunLoop Mode&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Run-Loop-Mode&quot;&gt;&lt;a href=&quot;#Run-Loop-Mode&quot; class=&quot;headerlink&quot; title=&quot;Run Loop Mode&quot;&gt;&lt;/a&gt;Run Loop Mode&lt;/h3&gt;&lt;p&gt;Apple文档定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A run loop mode is a collection of input sources and timers to be monitored and a collection of run loop observers to be notified.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字面理解，run loop mode就是：包含了一组需要监控对象（input source和timer）和一组需要通知的对象（loop observer）的集合。&lt;/p&gt;
&lt;p&gt;每次运行你的run loop，你都要指定（无论显示还是隐式）其运行的模式。在run loop运行过程中，只有和模式相关的源才会被监视并允许他们传递事件消息。（类似的，只有和模式相关的观察者会通知run loop的进程）。和其他模式关联的源只有在run loop运行在其模式下才会运行，否则处于暂停状态。&lt;/p&gt;
&lt;p&gt;一个 RunLoop 可以包含若干个 RunLoop Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定run loop运行在其中一个 Mode 上，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出当前运行的Run Loop，再重新指定一个 Mode 重新进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。&lt;/p&gt;
&lt;p&gt;在代码中，我们可以通过指定名字来标识模式。Cocoa和Core foundation定义了一个默认的和一些常用的模式，使用字符串来标识这些模式。我们也可以给模式名称指定一个字符串来自定义模式。虽然你可以给模式指定任意名字，但是模式的内容则不能是任意的。你必须添加一个或多个输入源，定时源或者run loop的观察者到你新建的模式中让他们起作用。&lt;/p&gt;
&lt;p&gt;以下是系统中已经定义的Mode：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSDefaultRunLoopMode: 大多数工作中默认的运行方式。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSConnectionReplyMode: 使用这个Mode去监听NSConnection对象的状态，我们很少需要自己使用这个Mode。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSModalPanelRunLoopMode: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UITrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GSEventReceiveRunLoopMode: 用来接受系统事件，内部的Run Loop Mode。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;值得需要记住的几个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run Loop运行时只能以一种固定的Mode运行，只会监控这个Mode下添加的Timer source和Input source。如果这个Mode下没有添加事件源，Run Loop会立刻返回。&lt;/li&gt;
&lt;li&gt;Run Loop不能在运行在NSRunLoopCommonModes，因为NSRunLoopCommonModes是个Mode集合，而不是一个具体的Mode。我们可以在添加事件源的时候使用NSRunLoopCommonModes，只要Run Loop运行在NSRunLoopCommonModes中任何一个Mode，这个事件源都可以被触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;RunLoop的输入源&quot;&gt;&lt;a href=&quot;#RunLoop的输入源&quot; class=&quot;headerlink&quot; title=&quot;RunLoop的输入源&quot;&gt;&lt;/a&gt;RunLoop的输入源&lt;/h3&gt;&lt;p&gt;Input source有两个不同的种类: Port-Based Sources 和 Custom Input Sources。Run Loop本身并不关心Input source是哪一种类型。系统会实现两种不同的Input source供我们使用。这两种不同类型的Input source的区别在于：Port-Based Sources由内核自动发送，Custom Input Sources需要从其他线程手动发送。&lt;/p&gt;
&lt;p&gt;当我们创建输入源后，需要将其分配给run loop中的一个或多个模式。模式只会在只会响应处理添加到自身模式下的事件源，而会忽略添加到其它模式下面的源。大多数情况下，run loop运行在默认模式下，但是你也可以使其运行在自定义模式或者其它指定的模式下。若某一源在当前模式下不被监听，那么任何其生成的消息只在run loop运行在其关联的模式下才会被传递。&lt;/p&gt;
&lt;h5 id=&quot;基于端口的输入源&quot;&gt;&lt;a href=&quot;#基于端口的输入源&quot; class=&quot;headerlink&quot; title=&quot;基于端口的输入源&quot;&gt;&lt;/a&gt;基于端口的输入源&lt;/h5&gt;&lt;p&gt;通过内置的端口相关的对象和函数，配置基于端口的Input source。 (比如在主线程创建子线程时传入一个NSPort对象,主线程和子线程就可以进行通讯。NSPort对象会负责自己创建和配置Input source。)&lt;/p&gt;
&lt;h5 id=&quot;自定义的输入源&quot;&gt;&lt;a href=&quot;#自定义的输入源&quot; class=&quot;headerlink&quot; title=&quot;自定义的输入源&quot;&gt;&lt;/a&gt;自定义的输入源&lt;/h5&gt;&lt;p&gt;为了创建自定义输入源，必须使用Core Foundation里面的CFRunLoopSourceRef类型相关的函数来创建。可以使用回调函数来配置自定义输入源。Core Fundation会在配置源的不同地方调用回调函数，处理输入事件，当从run loop移除的时候清理它。&lt;/p&gt;
&lt;h5 id=&quot;Cocoa-Perform-Selector-Sources&quot;&gt;&lt;a href=&quot;#Cocoa-Perform-Selector-Sources&quot; class=&quot;headerlink&quot; title=&quot;Cocoa Perform Selector Sources&quot;&gt;&lt;/a&gt;Cocoa Perform Selector Sources&lt;/h5&gt;&lt;p&gt;除了基于端口的源，Cocoa也为我们提供了自定义的输入源，允许我们在任何线程执行selector。和基于端口的源一样，执行selector请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题。不像基于端口的源，一个selector执行完后会自动从run loop里面移除。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;RunLoopTimer（定时源）&quot;&gt;&lt;a href=&quot;#RunLoopTimer（定时源）&quot; class=&quot;headerlink&quot; title=&quot;RunLoopTimer（定时源）&quot;&gt;&lt;/a&gt;RunLoopTimer（定时源）&lt;/h3&gt;&lt;p&gt;Timer source在预设的时间点同步的传递消息。Timer是线程通知自己做某件事的一种方式。&lt;/p&gt;
&lt;p&gt;Foundation中 NSTimer Class提供了相关方法来设置Timer source。需要注意的是除了scheduledTimerWithTimeInterval开头的方法创建的Timer都需要手动添加到当前Run Loop中。（scheduledTimerWithTimeInterval 创建的timer会自动以Default Mode加载到当前Run Loop中。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Timer在选择使用一次后，在执行完成时，会从Run Loop中移除。选择循环时，会一直保存在当前Run Loop中，直到调用invalidated方法。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;RunLoopObserver&quot;&gt;&lt;a href=&quot;#RunLoopObserver&quot; class=&quot;headerlink&quot; title=&quot;RunLoopObserver&quot;&gt;&lt;/a&gt;RunLoopObserver&lt;/h3&gt;&lt;p&gt;事件源是同步或者异步的事件驱动时触发，而Run Loop Observer则在Run Loop本身进入某个状态时得到通知:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Run Loop 进入的时候&lt;br&gt;Run Loop 处理一个Timer的时候&lt;br&gt;Run Loop 处理一个Input Source的时候&lt;br&gt;Run Loop 进入睡眠的时候&lt;br&gt;Run Loop 被唤醒的时候，在唤醒它的事件被处理之前&lt;br&gt;Run Loop 停止的时候&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;和定时器类似，run loop观察者可以只用一次或循环使用。若只用一次，那么在它启动后，会把它自己从run loop里面移除，而循环的观察者则不会。你在创建run loop观察者的时候需要指定它是运行一次还是多次。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Run-Loop内部实现&quot;&gt;&lt;a href=&quot;#Run-Loop内部实现&quot; class=&quot;headerlink&quot; title=&quot;Run Loop内部实现&quot;&gt;&lt;/a&gt;Run Loop内部实现&lt;/h3&gt;&lt;p&gt;CFRunLoop中主要使用&lt;em&gt;CFRunLoopRun&lt;/em&gt;和&lt;em&gt;CFRunLoopRunSpecific&lt;/em&gt;函数来启动run loop过程。而&lt;em&gt;CFRunLoopRun&lt;/em&gt;和&lt;em&gt;CFRunLoopRunSpecific&lt;/em&gt;函数内部都调用了&lt;em&gt;CFRunLoopRunSepcific&lt;/em&gt;函数，&lt;em&gt;CFRunLoopRunSepcific&lt;/em&gt;函数内部调用了&lt;em&gt;__CFRunLoopRun&lt;/em&gt;函数。&lt;/p&gt;
&lt;p&gt;我们也可以查看一下CFRunLoop的&lt;a href=&quot;http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;开源代码&lt;/a&gt;，能够发现大概如下的过程：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;85&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;86&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;87&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;88&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;89&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;90&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;91&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;92&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;93&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;94&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;95&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;96&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;97&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;98&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;99&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;100&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;101&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;102&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;103&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;104&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;105&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;106&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;107&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;108&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;109&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;110&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;111&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;112&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;113&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;114&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;115&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;116&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;117&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;118&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;119&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;120&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;121&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;122&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;123&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;124&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;125&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;126&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;127&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;128&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;129&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;130&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;131&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;132&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;133&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;134&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;135&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;136&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;137&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;138&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;139&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;140&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;141&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;142&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;143&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;144&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;145&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;146&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;147&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;148&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;149&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;150&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;151&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;152&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;153&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;154&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;155&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;156&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;157&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;158&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;159&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;160&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;161&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;162&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;163&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;164&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;165&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;166&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;167&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;168&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/*用defaultMode，启动线程的run loop*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void CFRunLoopRun(void) &amp;#123;	/* DOES CALLOUT */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int32_t result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    do &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        /* 循环检查 */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; while (kCFRunLoopRunStopped != result &amp;amp;&amp;amp; kCFRunLoopRunFinished != result);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/*用指定的Mode，开启线程的run loop，可以指定run loop超时结束的时间*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &amp;#123;     /* DOES CALLOUT */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/*run loop的执行方式*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &amp;#123;     /* DOES CALLOUT */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /*根据modeName查找 run loop mode*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* run loop mode不存在，返回run loop结束状态kCFRunLoopRunFinished*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&amp;gt;_currentMode)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    return kCFRunLoopRunFinished;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* 记录run loop原有的mode为previousMode，更新run loop中的mode为新查找到的currentMode*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFRunLoopModeRef previousMode = rl-&amp;gt;_currentMode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    rl-&amp;gt;_currentMode = currentMode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* 初始化run loop的状态*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int32_t result = kCFRunLoopRunFinished;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* 通知observer， run loop开始启动，状态是kCFRunLoopEntry*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if (currentMode-&amp;gt;_observerMask &amp;amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	/*run loop的具体实现， 调用内部函数__CFRunLoopRun*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	/* 通知observer， run loop结束了，状态是kCFRunLoopExit*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if (currentMode-&amp;gt;_observerMask &amp;amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* 读取当前的run loop mode数据， 并设置为previousMode， 为下一次run loop使用*/    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    __CFRunLoopPopPerRunData(rl, previousPerRun);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	rl-&amp;gt;_currentMode = previousMode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/* 内部函数__CFRunLoopRun的实现方式，这个才是run loop执行的真正实现的地方&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;** 去掉了关于对象锁机制的读写操作和一些不影响理解的代码段&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* 此处省略了一大段关于判断队列安全性和timeout的代码*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Boolean didDispatchPortLastTime = true;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int32_t retVal = 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    do &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        uint8_t msg_buffer[3 * 1024];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mach_msg_header_t *msg = NULL;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mach_port_t livePort = MACH_PORT_NULL;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        __CFRunLoopUnsetIgnoreWakeUps(rl);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        /*通知observer， run loop即将触发timer的回调*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        /*通知observer， run loop即将触发source0的回调*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        //执行需要完成的block代码&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    __CFRunLoopDoBlocks(rl, rlm);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        //run loop触发了source0的回调，处理source0的任务&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        /*__CFRunLoopDoSources0 函数调用了内部函数__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__来处理接受的事件，通过之前的断点堆栈可以验证这个过程*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (sourceHandledThisLoop) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            __CFRunLoopDoBlocks(rl, rlm);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&amp;gt;termTSR);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        /*检查是否接受到了来自系统的mach ports的事件*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (MACH_PORT_NULL != dispatchPort &amp;amp;&amp;amp; !didDispatchPortLastTime) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            msg = (mach_msg_header_t *)msg_buffer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            //如果有需要处理source1的消息，则直接开始处理这个消息&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, 0)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                goto handle_msg; //跳转到消息处理代码模块&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        didDispatchPortLastTime = false;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /*通知observer，run loop即将进入休眠状态*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopBeforeWaiting)) &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 //设置run loop休眠   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	__CFRunLoopSetSleeping(rl);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* 到这个时候我们的run loop已经进入了休眠的状态，如果没有事件去唤醒它，run loop将一直处于sleep的状态或者说处于等待被唤醒的状态。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    *  能够唤醒run loop的事件：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    *  - 基于mach ports的source1事件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    *  - timer时间到了&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    *  - runloop的超时时间到了（run loop超时就退出了）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    *  - 其他的手动唤醒事件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        msg = (mach_msg_header_t *)msg_buffer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        __CFRunLoopServiceMachPort(waitSet, &amp;amp;msg, sizeof(msg_buffer), &amp;amp;livePort, poll ? 0 : TIMEOUT_INFINITY);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //run loop 被唤醒了，又满血复活，通知Observer，我胡汉三又回来了&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if (!poll &amp;amp;&amp;amp; (rlm-&amp;gt;_observerMask &amp;amp; kCFRunLoopAfterWaiting)) &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        handle_msg:; // 处理接收的消息&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if (MACH_PORT_NULL == livePort) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            CFRUNLOOP_WAKEUP_FOR_NOTHING();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            // handle nothing&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; else if (livePort == rl-&amp;gt;_wakeUpPort) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            CFRUNLOOP_WAKEUP_FOR_WAKEUP();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            // do nothing on Mac OS&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        else if (livePort == dispatchPort) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            CFRUNLOOP_WAKEUP_FOR_DISPATCH();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 	        sourceHandledThisLoop = true;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            didDispatchPortLastTime = true;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            CFRUNLOOP_WAKEUP_FOR_SOURCE();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            if (rls) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                /*处理source1的事件*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		        sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&amp;gt;msgh_size, &amp;amp;reply) || sourceHandledThisLoop;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		    if (NULL != reply) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		        (void)mach_msg(reply, MACH_SEND_MSG, reply-&amp;gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     //执行需要完成的block代码 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	__CFRunLoopDoBlocks(rl, rlm);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //检查事件处理结束后的状态，如果结果是0，则继续run loop，否则退出。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	if (sourceHandledThisLoop &amp;amp;&amp;amp; stopAfterHandle) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    retVal = kCFRunLoopRunHandledSource;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; else if (timeout_context-&amp;gt;termTSR &amp;lt; mach_absolute_time()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            retVal = kCFRunLoopRunTimedOut;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; else if (__CFRunLoopIsStopped(rl)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            __CFRunLoopUnsetStopped(rl);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    retVal = kCFRunLoopRunStopped;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; else if (rlm-&amp;gt;_stopped) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    rlm-&amp;gt;_stopped = false;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    retVal = kCFRunLoopRunStopped;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    retVal = kCFRunLoopRunFinished;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; while (0 == retVal);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return retVal;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们不难发现，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。&lt;/p&gt;
&lt;p&gt;整个执行的流程可以借用下面的图帮助理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocgehzzvy.bkt.clouddn.com/runLoopLogic.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;我们什么时候需要用到run-loop&quot;&gt;&lt;a href=&quot;#我们什么时候需要用到run-loop&quot; class=&quot;headerlink&quot; title=&quot;我们什么时候需要用到run loop&quot;&gt;&lt;/a&gt;我们什么时候需要用到run loop&lt;/h2&gt;&lt;p&gt;通过阅读Apple的&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;我们可以发现，只有当程序中创建了新的子线程的时候才可能需要启动run loop。程序中的main thread中的run loop是在程序运行启动的时候，已经默认自动的启动好了，不需要显示的加以启动。 &lt;/p&gt;
&lt;p&gt;对于我们自己新创建的子线程来说，如果需要启动run loop，则必须对run loop进行必要的配置和加以显示的启动。因为子线程中的run loop是不会自动运行的。子线程不需要对所有的情况都使用run loop来处理事件，比如对于一些需要长时间处理的任务和已经预设好的任务则不用run loop。&lt;/p&gt;
&lt;p&gt;而对于一些和线程交互密切的任务则可以使用run loop来处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用ports和自定义的输入源来进行进程间的通信&lt;/li&gt;
&lt;li&gt;线程中使用timer&lt;/li&gt;
&lt;li&gt;线程中使用performSelector…函数簇  &lt;/li&gt;
&lt;li&gt;线程需要处理周期性的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本人能力有限，可能很多地方讲的不是很清楚，甚至有些地方不对。&lt;br&gt;文章中的大部分概念性的东西都是参考了Apple的官方文档加以自己的理解写出来的，同时也参考了CFRunLoop的开源代码。&lt;br&gt;在这里只是提到了一些RunLoop的概念性东西，对于它的作用和在实际应用中的使用没有提及。&lt;br&gt;我会继续深入的研究这部分的内容，并完成一些Demo。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深入理解RunLoop&lt;/a&gt;，by ibireme&lt;/li&gt;
&lt;li&gt;sunnyxx关于RunLoop的线下分享视频&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章是自己对于学习iOS底层的 RunLoop 的一个整理和记录，主要参考了 Apple 的官方文档和网上大神们的文章，然后加以自己的理解和验证完成的。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
</feed>
